(* pretty-printer generated by the BNF converter *)

open Abscacao
open Printf

(* We use string buffers for efficient string concatenation.
   A document takes a buffer and an indentation, has side effects on the buffer
   and returns a new indentation. The indentation argument indicates the level
   of indentation to be used if a new line has to be started (because of what is
   already in the buffer) *)
type doc = Buffer.t -> int -> int

let rec printTree (printer : int -> 'a -> doc) (tree : 'a) : string = 
    let buffer_init_size = 16 (* you may want to change this *)
    in let buffer = Buffer.create buffer_init_size
    in 
        let _ = printer 0 tree buffer 0 in (* discard return value *)
        Buffer.contents buffer

let indent_width = 4

let indent (i: int) : string = 
    let s = String.make (i+1) ' ' in
    String.set s 0 '\n';
    s

(* this render function is written for C-style languages, you may want to change it *)
let render (s : string) : doc = fun buf i -> 
    (* invariant: last char of the buffer is never whitespace *)
    let n = Buffer.length buf in
    let last = if n = 0 then None else Some (Buffer.nth buf (n-1)) in
    let whitespace = match last with
        None -> "" 
      | Some '{' -> indent i
      | Some '}' -> (match s with
            ";" -> ""
          | _ -> indent i)
      | Some ';' -> indent i
      | (Some '[') |  (Some '(') -> ""
      | Some _ -> (match s with
            "," | ")" | "]" -> ""
           | _ -> " ") in
    let newindent = match s with
        "{" -> i + indent_width
      | "}" -> i - indent_width
      | _ -> i in
    Buffer.add_string buf whitespace;
    Buffer.add_string buf s;
    newindent

let emptyDoc : doc = fun buf i -> i

let concatD (ds : doc list) : doc = fun buf i -> 
    List.fold_left (fun accIndent elemDoc -> elemDoc buf accIndent) (emptyDoc buf i) ds

let parenth (d:doc) : doc = concatD [render "("; d; render ")"]

let prPrec (i:int) (j:int) (d:doc) : doc = if j<i then parenth d else d


let rec prtChar (_:int) (c:char) : doc = render ("'" ^ Char.escaped c ^ "'")



let rec prtInt (_:int) (i:int) : doc = render (string_of_int i)



let rec prtFloat (_:int) (f:float) : doc = render (sprintf "%f" f)



let rec prtString (_:int) (s:string) : doc = render ("\"" ^ String.escaped s ^ "\"")




let rec prtUIdent _ (UIdent i) : doc = render i


let rec prtLIdent _ (LIdent i) : doc = render i


let rec prtWild _ (Wild i) : doc = render i



let rec prtRequest (i:int) (e:request) : doc = match e with
       Evaluation expr -> prPrec i 0 (concatD [prtExpr 0 expr])
  |    TypeCheck (expr, type') -> prPrec i 0 (concatD [render "|-" ; prtExpr 0 expr ; render ":" ; prtTypeT 0 type'])
  |    ModelCheck (expr, form) -> prPrec i 0 (concatD [render "|=" ; prtExpr 0 expr ; render ":" ; prtForm 0 form])
  |    OuterShell outershellrequest -> prPrec i 0 (concatD [render ":!" ; prtOuterShellRequest 0 outershellrequest])
  |    InnerShell innershellrequest -> prPrec i 0 (concatD [prtInnerShellRequest 0 innershellrequest])


and prtExpr (i:int) (e:expr) : doc = match e with
       Sequence (expr0, expr) -> prPrec i 0 (concatD [prtExpr 0 expr0 ; render ";" ; prtExpr 1 expr])
  |    Application (expr, exprs) -> prPrec i 1 (concatD [prtExpr 1 expr ; prtExprListBNFC 2 exprs ; render ";;"])
  |    Supposition (pattern, expr0, expr) -> prPrec i 2 (concatD [render "let" ; prtPattern 0 pattern ; render "=" ; prtExpr 2 expr0 ; render "in" ; prtExpr 3 expr])
  |    Recurrence (pattern, expr0, expr) -> prPrec i 2 (concatD [render "let" ; render "rec" ; prtPattern 0 pattern ; render "=" ; prtExpr 2 expr0 ; render "in" ; prtExpr 3 expr])
  |    Abstraction (pattern, expr) -> prPrec i 3 (concatD [render "fun" ; prtPattern 0 pattern ; render "->" ; prtExpr 4 expr])
  |    Condition (expr0, expr1, expr) -> prPrec i 4 (concatD [render "if" ; prtExpr 4 expr0 ; render "then" ; prtExpr 5 expr1 ; render "else" ; prtExpr 5 expr])
  |    Comprehension (bindings, expr) -> prPrec i 4 (concatD [render "from" ; render "(" ; prtBindingListBNFC 0 bindings ; render ")" ; render "yield" ; prtExpr 5 expr])
  |    Consolidation (bindings, expr) -> prPrec i 4 (concatD [render "from" ; render "(" ; prtBindingListBNFC 0 bindings ; render ")" ; prtExpr 5 expr])
  |    Filtration (bindings, patterns, expr) -> prPrec i 4 (concatD [render "from" ; render "(" ; prtBindingListBNFC 0 bindings ; render "|" ; prtPatternListBNFC 0 patterns ; render ")" ; render "yield" ; prtExpr 5 expr])
  |    Concentration (bindings, patterns, expr) -> prPrec i 4 (concatD [render "from" ; render "(" ; prtBindingListBNFC 0 bindings ; render "|" ; prtPatternListBNFC 0 patterns ; render ")" ; prtExpr 5 expr])
  |    Equation (expr0, expr) -> prPrec i 4 (concatD [prtExpr 5 expr0 ; render "=" ; prtExpr 5 expr])
  |    ComparisonLT (expr0, expr) -> prPrec i 4 (concatD [prtExpr 5 expr0 ; render "<" ; prtExpr 5 expr])
  |    ComparisonGT (expr0, expr) -> prPrec i 4 (concatD [prtExpr 5 expr0 ; render ">" ; prtExpr 5 expr])
  |    ComparisonLTE (expr0, expr) -> prPrec i 4 (concatD [prtExpr 5 expr0 ; render "<=" ; prtExpr 5 expr])
  |    ComparisonGTE (expr0, expr) -> prPrec i 4 (concatD [prtExpr 5 expr0 ; render ">=" ; prtExpr 5 expr])
  |    Reflection variation -> prPrec i 5 (concatD [render "!" ; prtVariation 0 variation])
  |    Acquisition  -> prPrec i 5 (concatD [render "newP"])
  |    Suspension (expr0, expr) -> prPrec i 5 (concatD [render "pushP" ; prtExpr 5 expr0 ; prtExpr 5 expr])
  |    Release (expr0, expr) -> prPrec i 5 (concatD [render "takeSC" ; prtExpr 5 expr0 ; prtExpr 5 expr])
  |    InnerSuspension (expr0, expr) -> prPrec i 5 (concatD [render "pushSC" ; prtExpr 5 expr0 ; prtExpr 5 expr])
  |    Calculation arithmeticexpr -> prPrec i 5 (concatD [prtArithmeticExpr 0 arithmeticexpr])

and prtExprListBNFC _ es : doc = match es with
  | [x]   -> (concatD [prtExpr 2 x])
  | x::xs -> (concatD [prtExpr 2 x ; prtExprListBNFC 2 xs])

and prtArithmeticExpr (i:int) (e:arithmeticExpr) : doc = match e with
       Division (arithmeticexpr0, arithmeticexpr) -> prPrec i 0 (concatD [prtArithmeticExpr 0 arithmeticexpr0 ; render "/" ; prtArithmeticExpr 1 arithmeticexpr])
  |    Addition (arithmeticexpr0, arithmeticexpr) -> prPrec i 1 (concatD [prtArithmeticExpr 1 arithmeticexpr0 ; render "+" ; prtArithmeticExpr 2 arithmeticexpr])
  |    Multiplication (arithmeticexpr0, arithmeticexpr) -> prPrec i 2 (concatD [prtArithmeticExpr 2 arithmeticexpr0 ; render "*" ; prtArithmeticExpr 3 arithmeticexpr])
  |    Juxtaposition (arithmeticexpr0, arithmeticexpr) -> prPrec i 3 (concatD [prtArithmeticExpr 3 arithmeticexpr0 ; render "::" ; prtArithmeticExpr 4 arithmeticexpr])
  |    Negation arithmeticexpr -> prPrec i 4 (concatD [render "-" ; prtArithmeticExpr 5 arithmeticexpr])
  |    Mention variation -> prPrec i 5 (concatD [prtVariation 0 variation])
  |    Actualization value -> prPrec i 5 (concatD [prtValue 0 value])
  |    Aggregation expr -> prPrec i 5 (concatD [render "(" ; prtExpr 0 expr ; render ")"])


and prtBinding (i:int) (e:binding) : doc = match e with
       Question (pattern, expr) -> prPrec i 0 (concatD [prtPattern 0 pattern ; render "<-" ; prtExpr 5 expr])

and prtBindingListBNFC _ es : doc = match es with
    []    -> (concatD [])
  | [x]   -> (concatD [prtBinding 0 x])
  | x::xs -> (concatD [prtBinding 0 x ; render "," ; prtBindingListBNFC 0 xs])

and prtPattern (i:int) (e:pattern) : doc = match e with
       Element (symbol, patterns) -> prPrec i 0 (concatD [prtSymbol 0 symbol ; render "(" ; prtPatternListBNFC 0 patterns ; render ")"])
  |    Variable variation -> prPrec i 0 (concatD [prtVariation 0 variation])
  |    Materialization value -> prPrec i 0 (concatD [prtValue 0 value])
  |    Procession lyst -> prPrec i 0 (concatD [prtLyst 0 lyst])
  |    PtnSequence variation -> prPrec i 0 (concatD [render "@Seq" ; prtVariation 0 variation])
  |    PtnApplication (variation0, variation) -> prPrec i 0 (concatD [render "@App" ; prtVariation 0 variation0 ; prtVariation 0 variation])
  |    PtnSupposition (variation0, variation1, variation) -> prPrec i 0 (concatD [render "@Let" ; prtVariation 0 variation0 ; prtVariation 0 variation1 ; prtVariation 0 variation])
  |    PtnRecurrence (variation0, variation1, variation) -> prPrec i 0 (concatD [render "@Letrec" ; prtVariation 0 variation0 ; prtVariation 0 variation1 ; prtVariation 0 variation])
  |    PtnAbstraction (variation0, variation) -> prPrec i 0 (concatD [render "@Abs" ; prtVariation 0 variation0 ; prtVariation 0 variation])
  |    PtnCondition (variation0, variation1, variation) -> prPrec i 0 (concatD [render "@Cond" ; prtVariation 0 variation0 ; prtVariation 0 variation1 ; prtVariation 0 variation])
  |    PtnComprehend (variation0, variation) -> prPrec i 0 (concatD [render "@SelectFrom" ; prtVariation 0 variation0 ; prtVariation 0 variation])
  |    PtnConsolidate (variation0, variation) -> prPrec i 0 (concatD [render "@From" ; prtVariation 0 variation0 ; prtVariation 0 variation])
  |    PtnFiltration (variation0, variation1, variation) -> prPrec i 0 (concatD [render "@SelectFromWhere" ; prtVariation 0 variation0 ; prtVariation 0 variation1 ; prtVariation 0 variation])
  |    PtnConcentrate (variation0, variation1, variation) -> prPrec i 0 (concatD [render "@FromWhere" ; prtVariation 0 variation0 ; prtVariation 0 variation1 ; prtVariation 0 variation])
  |    PtnEquation (variation0, variation) -> prPrec i 0 (concatD [render "@Equate" ; prtVariation 0 variation0 ; prtVariation 0 variation])
  |    PtnCompLT (variation0, variation) -> prPrec i 0 (concatD [render "@CompLT" ; prtVariation 0 variation0 ; prtVariation 0 variation])
  |    PtnCompGT (variation0, variation) -> prPrec i 0 (concatD [render "@CompGT" ; prtVariation 0 variation0 ; prtVariation 0 variation])
  |    PtnCompLTE (variation0, variation) -> prPrec i 0 (concatD [render "@CompLTE" ; prtVariation 0 variation0 ; prtVariation 0 variation])
  |    PtnCompGTE (variation0, variation) -> prPrec i 0 (concatD [render "@CompGTE" ; prtVariation 0 variation0 ; prtVariation 0 variation])
  |    PtnReflection (variation0, variation) -> prPrec i 0 (concatD [render "@Unquote" ; prtVariation 0 variation0 ; prtVariation 0 variation])
  |    PtnAcquisition  -> prPrec i 0 (concatD [render "@Newprompt"])
  |    PtnSuspension (variation0, variation) -> prPrec i 0 (concatD [render "@Suspend" ; prtVariation 0 variation0 ; prtVariation 0 variation])
  |    PtnRelease (variation0, variation) -> prPrec i 0 (concatD [render "@Release" ; prtVariation 0 variation0 ; prtVariation 0 variation])
  |    PtnInnerSuspend (variation0, variation) -> prPrec i 0 (concatD [render "@SuspendSub" ; prtVariation 0 variation0 ; prtVariation 0 variation])
  |    PtnDivision (variation0, variation) -> prPrec i 0 (concatD [render "@Divide" ; prtVariation 0 variation0 ; prtVariation 0 variation])
  |    PtnAddition (variation0, variation) -> prPrec i 0 (concatD [render "@Add" ; prtVariation 0 variation0 ; prtVariation 0 variation])
  |    PtnMultiply (variation0, variation) -> prPrec i 0 (concatD [render "@Multiply" ; prtVariation 0 variation0 ; prtVariation 0 variation])
  |    PtnJuxtapose (variation0, variation) -> prPrec i 0 (concatD [render "@Juxtapose" ; prtVariation 0 variation0 ; prtVariation 0 variation])
  |    PtnNegate (variation0, variation) -> prPrec i 0 (concatD [render "@Negate" ; prtVariation 0 variation0 ; prtVariation 0 variation])

and prtPatternListBNFC _ es : doc = match es with
  | [x]   -> (concatD [prtPattern 0 x])
  | x::xs -> (concatD [prtPattern 0 x ; render "," ; prtPatternListBNFC 0 xs])

and prtVariation (i:int) (e:variation) : doc = match e with
       Atomic uident -> prPrec i 0 (concatD [prtUIdent 0 uident])
  |    Abandon wild -> prPrec i 0 (concatD [prtWild 0 wild])
  |    Transcription expr -> prPrec i 0 (concatD [render "`" ; prtExpr 0 expr ; render "'"])


and prtLyst (i:int) (e:lyst) : doc = match e with
       Empty  -> prPrec i 0 (concatD [render "[" ; render "]"])
  |    Enum patterns -> prPrec i 0 (concatD [render "[" ; prtPatternListBNFC 0 patterns ; render "]"])
  |    Cons (patterns, lyst) -> prPrec i 0 (concatD [render "[" ; prtPatternListBNFC 0 patterns ; render "|" ; prtLyst 0 lyst ; render "]"])
  |    ConsV (patterns, variation) -> prPrec i 0 (concatD [render "[" ; prtPatternListBNFC 0 patterns ; render "|" ; prtVariation 0 variation ; render "]"])


and prtValue (i:int) (e:value) : doc = match e with
       BooleanLiteral duality -> prPrec i 0 (concatD [prtDuality 0 duality])
  |    StringLiteral str -> prPrec i 0 (concatD [prtString 0 str])
  |    IntegerLiteral n -> prPrec i 0 (concatD [prtInt 0 n])
  |    DoubleLiteral d -> prPrec i 0 (concatD [prtFloat 0 d])
  |    Reification expr -> prPrec i 0 (concatD [render "<<" ; prtExpr 0 expr ; render ">>"])


and prtDuality (i:int) (e:duality) : doc = match e with
       Verity  -> prPrec i 0 (concatD [render "true"])
  |    Absurdity  -> prPrec i 0 (concatD [render "false"])


and prtSymbol (i:int) (e:symbol) : doc = match e with
       Tag lident -> prPrec i 0 (concatD [prtLIdent 0 lident])


and prtTypeT (i:int) (e:typeT) : doc = match e with
       ProductType (type'0, type') -> prPrec i 0 (concatD [prtTypeT 0 type'0 ; render "*" ; prtTypeT 1 type'])
  |    AbstractionType typeabstraction -> prPrec i 1 (concatD [prtTypeAbstraction 0 typeabstraction])
  |    ApplicationType typeapplication -> prPrec i 1 (concatD [prtTypeApplication 0 typeapplication])
  |    FunctionType (type'0, type') -> prPrec i 2 (concatD [prtTypeT 2 type'0 ; render "->" ; prtTypeT 3 type'])
  |    UserDefinedType lident -> prPrec i 4 (concatD [prtLIdent 0 lident])
  |    GroundType gtype -> prPrec i 4 (concatD [prtGType 0 gtype])
  |    StructuralType structuretype -> prPrec i 4 (concatD [prtStructureType 0 structuretype])

and prtTypeTListBNFC _ es : doc = match es with
  | [x]   -> (concatD [prtTypeT 1 x])
  | x::xs -> (concatD [prtTypeT 1 x ; render "," ; prtTypeTListBNFC 1 xs])

and prtTypeAbstraction (i:int) (e:typeAbstraction) : doc = match e with
       TypeListFormals (typevars, type') -> prPrec i 0 (concatD [render "(" ; prtTypeVarListBNFC 0 typevars ; render ")" ; prtTypeT 4 type'])


and prtTypeApplication (i:int) (e:typeApplication) : doc = match e with
       TypeListActuals (types, type') -> prPrec i 0 (concatD [render "[" ; prtTypeTListBNFC 1 types ; render "]" ; prtTypeT 4 type'])


and prtTypeVar (i:int) (e:typeVar) : doc = match e with
       AtomicTypeVar lident -> prPrec i 0 (concatD [render "'" ; prtLIdent 0 lident])
  |    TermTypeVar type' -> prPrec i 0 (concatD [render "`" ; prtTypeT 2 type'])

and prtTypeVarListBNFC _ es : doc = match es with
  | [x]   -> (concatD [prtTypeVar 0 x])
  | x::xs -> (concatD [prtTypeVar 0 x ; render "," ; prtTypeVarListBNFC 0 xs])

and prtStructureType (i:int) (e:structureType) : doc = match e with
       ReflectionType type' -> prPrec i 0 (concatD [render "!" ; prtTypeT 4 type'])
  |    AggregationType type' -> prPrec i 0 (concatD [render "(" ; prtTypeT 0 type' ; render ")"])


and prtGType (i:int) (e:gType) : doc = match e with
       BooleanType  -> prPrec i 0 (concatD [render "bool"])
  |    StringType  -> prPrec i 0 (concatD [render "string"])
  |    IntegerType  -> prPrec i 0 (concatD [render "int"])
  |    FloatType  -> prPrec i 0 (concatD [render "float"])


and prtForm (i:int) (e:form) : doc = match e with
       ConjunctiveForm (form0, form) -> prPrec i 0 (concatD [prtForm 0 form0 ; render "&" ; prtForm 1 form])
  |    DisjunctiveForm (form0, form) -> prPrec i 1 (concatD [prtForm 1 form0 ; render "+" ; prtForm 2 form])
  |    ImplicativeForm (form0, form) -> prPrec i 2 (concatD [prtForm 2 form0 ; render "=>" ; prtForm 3 form])
  |    ProductiveForm (form0, form) -> prPrec i 3 (concatD [prtForm 3 form0 ; render "*" ; prtForm 4 form])
  |    AbstractionForm (formformals, form) -> prPrec i 4 (concatD [prtFormFormals 0 formformals ; prtForm 5 form])
  |    ProbativeForm (form0, form) -> prPrec i 5 (concatD [render "<" ; prtForm 5 form0 ; render ">" ; prtForm 6 form])
  |    RecursiveForm (uident, form) -> prPrec i 6 (concatD [render "rec" ; prtUIdent 0 uident ; render "->" ; prtForm 6 form])
  |    ReflectionForm form -> prPrec i 6 (concatD [render "!" ; prtForm 6 form])
  |    NegativeForm form -> prPrec i 6 (concatD [render "~" ; prtForm 6 form])
  |    ReferentialForm uident -> prPrec i 6 (concatD [prtUIdent 0 uident])
  |    UserDefinedForm lident -> prPrec i 6 (concatD [prtLIdent 0 lident])
  |    GroundForm gform -> prPrec i 6 (concatD [prtGForm 0 gform])


and prtFormFormals (i:int) (e:formFormals) : doc = match e with
       FormOneFormal formvar -> prPrec i 0 (concatD [prtFormVar 0 formvar])
  |    FormListFormals formvars -> prPrec i 0 (concatD [render "(" ; prtFormVarListBNFC 0 formvars ; render ")"])


and prtFormVar (i:int) (e:formVar) : doc = match e with
       AtomicFormVar lident -> prPrec i 0 (concatD [render "'" ; prtLIdent 0 lident])
  |    TermFormVar form -> prPrec i 0 (concatD [render "`" ; prtForm 2 form])

and prtFormVarListBNFC _ es : doc = match es with
  | [x]   -> (concatD [prtFormVar 0 x])
  | x::xs -> (concatD [prtFormVar 0 x ; render "," ; prtFormVarListBNFC 0 xs])

and prtGForm (i:int) (e:gForm) : doc = match e with
       VerityForm  -> prPrec i 0 (concatD [render "T"])
  |    AbsurdityForm  -> prPrec i 0 (concatD [render "F"])
  |    BooleanForm  -> prPrec i 0 (concatD [render "bool"])
  |    StringForm  -> prPrec i 0 (concatD [render "string"])
  |    IntegerForm  -> prPrec i 0 (concatD [render "int"])
  |    FloatForm  -> prPrec i 0 (concatD [render "float"])


and prtOuterShellRequest (i:int) (e:outerShellRequest) : doc = match e with
       EscapeRequest str -> prPrec i 0 (concatD [prtString 0 str])
  |    PwdRequest  -> prPrec i 0 (concatD [render ":pwd"])
  |    CdRequest  -> prPrec i 0 (concatD [render ":cd"])


and prtInnerShellRequest (i:int) (e:innerShellRequest) : doc = match e with
       ExitRequest  -> prPrec i 0 (concatD [render ":exit"])
  |    TypeRequest expr -> prPrec i 0 (concatD [render ":type" ; prtExpr 0 expr])
  |    DesugarRequest expr -> prPrec i 0 (concatD [render ":desugar" ; prtExpr 0 expr])
  |    ParseRequest expr -> prPrec i 0 (concatD [render ":parse" ; prtExpr 0 expr])



