(* show functions generated by the BNF converter *)

open Abscacao

(* use string buffers for efficient string concatenations *)
type showable = Buffer.t -> unit

let show (s : showable) : string = 
    let init_size = 16 in (* you may want to adjust this *)
    let b = Buffer.create init_size in
    s b;
    Buffer.contents b
    
let emptyS : showable = fun buf -> ()

let c2s (c:char) : showable = fun buf -> Buffer.add_char buf c
let s2s (s:string) : showable = fun buf -> Buffer.add_string buf s

let ( >> ) (s1 : showable) (s2 : showable) : showable = fun buf -> s1 buf; s2 buf

let showChar (c:char) : showable = fun buf -> 
    Buffer.add_string buf ("'" ^ Char.escaped c ^ "'")

let showString (s:string) : showable = fun buf -> 
    Buffer.add_string buf ("\"" ^ String.escaped s ^ "\"")

let showList (showFun : 'a -> showable) (xs : 'a list) : showable = fun buf -> 
    let rec f ys = match ys with
        [] -> ()
      | [y] -> showFun y buf
      | y::ys -> showFun y buf; Buffer.add_string buf "; "; f ys 
    in
        Buffer.add_char buf '[';
        f xs;
        Buffer.add_char buf ']'


let showInt (i:int) : showable = s2s (string_of_int i)
let showFloat (f:float) : showable = s2s (string_of_float f)

let rec showUIdent (UIdent i) : showable = s2s "UIdent " >> showString i

let rec showLIdent (LIdent i) : showable = s2s "LIdent " >> showString i

let rec showWild (Wild i) : showable = s2s "Wild " >> showString i


let rec showExpr (e:expr) : showable = match e with
       Sequence (expr0, expr) -> s2s "Sequence" >> c2s ' ' >> c2s '(' >> showExpr expr0  >> s2s ", " >>  showExpr expr >> c2s ')'
  |    Application (expr, exprs) -> s2s "Application" >> c2s ' ' >> c2s '(' >> showExpr expr  >> s2s ", " >>  showList showExpr exprs >> c2s ')'
  |    Supposition (pattern, expr0, expr) -> s2s "Supposition" >> c2s ' ' >> c2s '(' >> showPattern pattern  >> s2s ", " >>  showExpr expr0  >> s2s ", " >>  showExpr expr >> c2s ')'
  |    Recurrence (pattern, expr0, expr) -> s2s "Recurrence" >> c2s ' ' >> c2s '(' >> showPattern pattern  >> s2s ", " >>  showExpr expr0  >> s2s ", " >>  showExpr expr >> c2s ')'
  |    Abstraction (pattern, expr) -> s2s "Abstraction" >> c2s ' ' >> c2s '(' >> showPattern pattern  >> s2s ", " >>  showExpr expr >> c2s ')'
  |    Condition (expr0, expr1, expr) -> s2s "Condition" >> c2s ' ' >> c2s '(' >> showExpr expr0  >> s2s ", " >>  showExpr expr1  >> s2s ", " >>  showExpr expr >> c2s ')'
  |    Comprehension (bindings, expr) -> s2s "Comprehension" >> c2s ' ' >> c2s '(' >> showList showBinding bindings  >> s2s ", " >>  showExpr expr >> c2s ')'
  |    Filtration (bindings, patterns, expr) -> s2s "Filtration" >> c2s ' ' >> c2s '(' >> showList showBinding bindings  >> s2s ", " >>  showList showPattern patterns  >> s2s ", " >>  showExpr expr >> c2s ')'
  |    Equation (expr0, expr) -> s2s "Equation" >> c2s ' ' >> c2s '(' >> showExpr expr0  >> s2s ", " >>  showExpr expr >> c2s ')'
  |    ComparisonLT (expr0, expr) -> s2s "ComparisonLT" >> c2s ' ' >> c2s '(' >> showExpr expr0  >> s2s ", " >>  showExpr expr >> c2s ')'
  |    ComparisonGT (expr0, expr) -> s2s "ComparisonGT" >> c2s ' ' >> c2s '(' >> showExpr expr0  >> s2s ", " >>  showExpr expr >> c2s ')'
  |    ComparisonLTE (expr0, expr) -> s2s "ComparisonLTE" >> c2s ' ' >> c2s '(' >> showExpr expr0  >> s2s ", " >>  showExpr expr >> c2s ')'
  |    ComparisonGTE (expr0, expr) -> s2s "ComparisonGTE" >> c2s ' ' >> c2s '(' >> showExpr expr0  >> s2s ", " >>  showExpr expr >> c2s ')'
  |    Calculation arithmeticexpr -> s2s "Calculation" >> c2s ' ' >> c2s '(' >> showArithmeticExpr arithmeticexpr >> c2s ')'


and showArithmeticExpr (e:arithmeticExpr) : showable = match e with
       Division (arithmeticexpr0, arithmeticexpr) -> s2s "Division" >> c2s ' ' >> c2s '(' >> showArithmeticExpr arithmeticexpr0  >> s2s ", " >>  showArithmeticExpr arithmeticexpr >> c2s ')'
  |    Addition (arithmeticexpr0, arithmeticexpr) -> s2s "Addition" >> c2s ' ' >> c2s '(' >> showArithmeticExpr arithmeticexpr0  >> s2s ", " >>  showArithmeticExpr arithmeticexpr >> c2s ')'
  |    Multiplication (arithmeticexpr0, arithmeticexpr) -> s2s "Multiplication" >> c2s ' ' >> c2s '(' >> showArithmeticExpr arithmeticexpr0  >> s2s ", " >>  showArithmeticExpr arithmeticexpr >> c2s ')'
  |    Juxtaposition (arithmeticexpr0, arithmeticexpr) -> s2s "Juxtaposition" >> c2s ' ' >> c2s '(' >> showArithmeticExpr arithmeticexpr0  >> s2s ", " >>  showArithmeticExpr arithmeticexpr >> c2s ')'
  |    Negation arithmeticexpr -> s2s "Negation" >> c2s ' ' >> c2s '(' >> showArithmeticExpr arithmeticexpr >> c2s ')'
  |    Mention variation -> s2s "Mention" >> c2s ' ' >> c2s '(' >> showVariation variation >> c2s ')'
  |    Actualization value -> s2s "Actualization" >> c2s ' ' >> c2s '(' >> showValue value >> c2s ')'


and showBinding (e:binding) : showable = match e with
       Question (pattern, expr) -> s2s "Question" >> c2s ' ' >> c2s '(' >> showPattern pattern  >> s2s ", " >>  showExpr expr >> c2s ')'


and showPattern (e:pattern) : showable = match e with
       Element (symbol, patterns) -> s2s "Element" >> c2s ' ' >> c2s '(' >> showSymbol symbol  >> s2s ", " >>  showList showPattern patterns >> c2s ')'
  |    Variable variation -> s2s "Variable" >> c2s ' ' >> c2s '(' >> showVariation variation >> c2s ')'
  |    Materialization value -> s2s "Materialization" >> c2s ' ' >> c2s '(' >> showValue value >> c2s ')'
  |    Procession lyst -> s2s "Procession" >> c2s ' ' >> c2s '(' >> showLyst lyst >> c2s ')'


and showVariation (e:variation) : showable = match e with
       Atomic uident -> s2s "Atomic" >> c2s ' ' >> c2s '(' >> showUIdent uident >> c2s ')'
  |    Abandon wild -> s2s "Abandon" >> c2s ' ' >> c2s '(' >> showWild wild >> c2s ')'
  |    Transcription expr -> s2s "Transcription" >> c2s ' ' >> c2s '(' >> showExpr expr >> c2s ')'


and showLyst (e:lyst) : showable = match e with
       Empty  -> s2s "Empty" 
  |    Enum patterns -> s2s "Enum" >> c2s ' ' >> c2s '(' >> showList showPattern patterns >> c2s ')'
  |    Cons (patterns, lyst) -> s2s "Cons" >> c2s ' ' >> c2s '(' >> showList showPattern patterns  >> s2s ", " >>  showLyst lyst >> c2s ')'
  |    ConsV (patterns, variation) -> s2s "ConsV" >> c2s ' ' >> c2s '(' >> showList showPattern patterns  >> s2s ", " >>  showVariation variation >> c2s ')'


and showValue (e:value) : showable = match e with
       BooleanLiteral duality -> s2s "BooleanLiteral" >> c2s ' ' >> c2s '(' >> showDuality duality >> c2s ')'
  |    StringLiteral str -> s2s "StringLiteral" >> c2s ' ' >> c2s '(' >> showString str >> c2s ')'
  |    IntegerLiteral n -> s2s "IntegerLiteral" >> c2s ' ' >> c2s '(' >> showInt n >> c2s ')'
  |    DoubleLiteral d -> s2s "DoubleLiteral" >> c2s ' ' >> c2s '(' >> showFloat d >> c2s ')'
  |    Reification expr -> s2s "Reification" >> c2s ' ' >> c2s '(' >> showExpr expr >> c2s ')'


and showDuality (e:duality) : showable = match e with
       Verity  -> s2s "Verity" 
  |    Absurdity  -> s2s "Absurdity" 


and showSymbol (e:symbol) : showable = match e with
       Tag lident -> s2s "Tag" >> c2s ' ' >> c2s '(' >> showLIdent lident >> c2s ')'



