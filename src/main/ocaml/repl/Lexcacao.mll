(* This ocamllex file was machine-generated by the BNF converter *)
{
open Parcacao
open Lexing
open BatChar

let symbol_table = Hashtbl.create 63
let _ = List.iter (fun (kwd, tok) -> Hashtbl.add symbol_table kwd tok)
                  [("|-", SYMB1);(":", SYMB2);("|=", SYMB3);(";", SYMB4);(";;", SYMB5);("=", SYMB6);("->", SYMB7);("(", SYMB8);(")", SYMB9);("|", SYMB10);("<", SYMB11);(">", SYMB12);("<=", SYMB13);(">=", SYMB14);("!", SYMB15);("/", SYMB16);("+", SYMB17);("*", SYMB18);("::", SYMB19);("-", SYMB20);("<-", SYMB21);("@Seq", SYMB22);("@App", SYMB23);("@Let", SYMB24);("@Letrec", SYMB25);("@Abs", SYMB26);("@Cond", SYMB27);("@SelectFrom", SYMB28);("@From", SYMB29);("@SelectFromWhere", SYMB30);("@FromWhere", SYMB31);("@Equate", SYMB32);("@CompLT", SYMB33);("@CompGT", SYMB34);("@CompLTE", SYMB35);("@CompGTE", SYMB36);("@Unquote", SYMB37);("@Newprompt", SYMB38);("@Suspend", SYMB39);("@Release", SYMB40);("@SuspendSub", SYMB41);("@Divide", SYMB42);("@Add", SYMB43);("@Multiply", SYMB44);("@Juxtapose", SYMB45);("@Negate", SYMB46);("`", SYMB47);("'", SYMB48);("[", SYMB49);("]", SYMB50);("<<", SYMB51);(">>", SYMB52);("&", SYMB53);("=>", SYMB54);("~", SYMB55);(":!", SYMB56);(":pwd", SYMB57);(":cd", SYMB58);(":exit", SYMB59);(":type", SYMB60);(":desugar", SYMB61);(":parse", SYMB62);(",", SYMB63)]

let resword_table = Hashtbl.create 21
let _ = List.iter (fun (kwd, tok) -> Hashtbl.add resword_table kwd tok)
                  [("F", TOK_F);("T", TOK_T);("bool", TOK_bool);("else", TOK_else);("false", TOK_false);("float", TOK_float);("from", TOK_from);("fun", TOK_fun);("if", TOK_if);("in", TOK_in);("int", TOK_int);("let", TOK_let);("newP", TOK_newP);("pushP", TOK_pushP);("pushSC", TOK_pushSC);("rec", TOK_rec);("string", TOK_string);("takeSC", TOK_takeSC);("then", TOK_then);("true", TOK_true);("yield", TOK_yield)]


let unescapeInitTail (s:string) : string =
  let rec unesc s = match s with
      '\\'::c::cs when List.mem c ['\"'; '\\'; '\''] -> c :: unesc cs
    | '\\'::'n'::cs  -> '\n' :: unesc cs
    | '\\'::'t'::cs  -> '\t' :: unesc cs
    | '\"'::[]    -> []
    | c::cs      -> c :: unesc cs
    | _         -> []
  (* explode/implode from caml FAQ *)
  in let explode (s : string) : char list =
      let rec exp i l =
        if i < 0 then l else exp (i - 1) (s.[i] :: l) in
      exp (String.length s - 1) []
  in let implode (l : char list) : string =
      let res = String.create (List.length l) in
      let rec imp i = function
      | [] -> res
      | c :: l -> res.[i] <- c; imp (i + 1) l in
      imp 0 l
  in implode (unesc (List.tl (explode s)))

let incr_lineno (lexbuf:Lexing.lexbuf) : unit =
    let pos = lexbuf.lex_curr_p in
        lexbuf.lex_curr_p <- { pos with
            pos_lnum = pos.pos_lnum + 1;
            pos_bol = pos.pos_cnum;
        }
}

let l = ['a'-'z' 'A'-'Z' '\192' - '\255'] # ['\215' '\247']    (*  isolatin1 letter FIXME *)
let c = ['A'-'Z' '\192'-'\221'] # ['\215']    (*  capital isolatin1 letter FIXME *)
let s = ['a'-'z' '\222'-'\255'] # ['\247']    (*  small isolatin1 letter FIXME *)
let d = ['0'-'9']                (*  digit *)
let i = l | d | ['_' '\'']          (*  identifier character *)
let u = ['\000'-'\255']           (* universal: any character *)
let rsyms =    (* reserved words consisting of special symbols *)
            "|-" | ":" | "|=" | ";" | ";;" | "=" | "->" | "(" | ")" | "|" | "<" | ">" | "<=" | ">=" | "!" | "/" | "+" | "*" | "::" | "-" | "<-" | "@Seq" | "@App" | "@Let" | "@Letrec" | "@Abs" | "@Cond" | "@SelectFrom" | "@From" | "@SelectFromWhere" | "@FromWhere" | "@Equate" | "@CompLT" | "@CompGT" | "@CompLTE" | "@CompGTE" | "@Unquote" | "@Newprompt" | "@Suspend" | "@Release" | "@SuspendSub" | "@Divide" | "@Add" | "@Multiply" | "@Juxtapose" | "@Negate" | "`" | "'" | "[" | "]" | "<<" | ">>" | "&" | "=>" | "~" | ":!" | ":pwd" | ":cd" | ":exit" | ":type" | ":desugar" | ":parse" | ","

rule token = 
    parse "//" (_ # '\n')*  { token lexbuf } (* Toss single line comments *)
        | "/*" ((u # ['*']) | '*' (u # ['/']))* ('*')+ '/' { token lexbuf } 

        | "(*" ((u # ['*']) | '*' (u # [')']))* ('*')+ ')' { token lexbuf } 

        | l i* {let id = lexeme lexbuf in try Hashtbl.find resword_table id with Not_found -> ( if ( is_uppercase id.[0] ) then ( TOK_UIdent id ) else ( TOK_LIdent id ) )} 
        | rsyms {let id = lexeme lexbuf in try Hashtbl.find symbol_table id with Not_found -> failwith ("internal lexer error: reserved symbol " ^ id ^ " not found in hashtable")}
        | d+ {let i = lexeme lexbuf in TOK_Integer (int_of_string i)}
        | d+ '.' d+ ('e' ('-')? d+)? {let f = lexeme lexbuf in TOK_Double (float_of_string f)}
        | '\"' ((u # ['\"' '\\' '\n']) | ('\\' ('\"' | '\\' | '\'' | 'n' | 't')))* '\"' {let s = lexeme lexbuf in TOK_String (unescapeInitTail s)}
        | [' ' '\t'] {token lexbuf}
        | '\n' {incr_lineno lexbuf; token lexbuf}
        | eof { TOK_EOF }
