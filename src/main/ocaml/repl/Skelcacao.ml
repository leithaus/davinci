module Skelcacao = struct

(* OCaml module generated by the BNF converter *)

open Abscacao

type result = string

let failure x = failwith "Undefined case." (* x discarded *)

let rec transUIdent (x : uIdent) : result = match x with
    UIdent str -> failure x


and transLIdent (x : lIdent) : result = match x with
    LIdent str -> failure x


and transWild (x : wild) : result = match x with
    Wild str -> failure x


and transExpr (x : expr) : result = match x with
    Sequence (expr0, expr) -> failure x
  | Application (expr, exprs) -> failure x
  | Supposition (pattern, expr0, expr) -> failure x
  | Recurrence (pattern, expr0, expr) -> failure x
  | Abstraction (pattern, expr) -> failure x
  | Condition (expr0, expr1, expr) -> failure x
  | Comprehension (bindings, expr) -> failure x
  | Filtration (bindings, patterns, expr) -> failure x
  | Equation (expr0, expr) -> failure x
  | ComparisonLT (expr0, expr) -> failure x
  | ComparisonGT (expr0, expr) -> failure x
  | ComparisonLTE (expr0, expr) -> failure x
  | ComparisonGTE (expr0, expr) -> failure x
  | Calculation arithmeticexpr -> failure x


and transArithmeticExpr (x : arithmeticExpr) : result = match x with
    Division (arithmeticexpr0, arithmeticexpr) -> failure x
  | Addition (arithmeticexpr0, arithmeticexpr) -> failure x
  | Multiplication (arithmeticexpr0, arithmeticexpr) -> failure x
  | Juxtaposition (arithmeticexpr0, arithmeticexpr) -> failure x
  | Negation arithmeticexpr -> failure x
  | Mention variation -> failure x
  | Actualization value -> failure x


and transBinding (x : binding) : result = match x with
    Question (pattern, expr) -> failure x


and transPattern (x : pattern) : result = match x with
    Element (symbol, patterns) -> failure x
  | Variable variation -> failure x
  | Materialization value -> failure x
  | Procession lyst -> failure x


and transVariation (x : variation) : result = match x with
    Atomic uident -> failure x
  | Abandon wild -> failure x
  | Transcription expr -> failure x


and transLyst (x : lyst) : result = match x with
    Empty  -> failure x
  | Enum patterns -> failure x
  | Cons (patterns, lyst) -> failure x
  | ConsV (patterns, variation) -> failure x


and transValue (x : value) : result = match x with
    BooleanLiteral duality -> failure x
  | StringLiteral str -> failure x
  | IntegerLiteral n -> failure x
  | DoubleLiteral d -> failure x
  | Reification expr -> failure x


and transDuality (x : duality) : result = match x with
    Verity  -> failure x
  | Absurdity  -> failure x


and transSymbol (x : symbol) : result = match x with
    Tag lident -> failure x



end
