module Skelcacao = struct

(* OCaml module generated by the BNF converter *)

open Abscacao

type result = string

let failure x = failwith "Undefined case." (* x discarded *)

let rec transUIdent (x : uIdent) : result = match x with
    UIdent str -> failure x


and transLIdent (x : lIdent) : result = match x with
    LIdent str -> failure x


and transWild (x : wild) : result = match x with
    Wild str -> failure x


and transRequest (x : request) : result = match x with
    Evaluation expr -> failure x
  | TypeCheck (expr, type') -> failure x
  | ModelCheck (expr, form) -> failure x
  | OuterShell outershellrequest -> failure x
  | InnerShell innershellrequest -> failure x


and transExpr (x : expr) : result = match x with
    Sequence (expr0, expr) -> failure x
  | Application (expr, exprs) -> failure x
  | Supposition (pattern, expr0, expr) -> failure x
  | Recurrence (pattern, expr0, expr) -> failure x
  | Abstraction (pattern, expr) -> failure x
  | Condition (expr0, expr1, expr) -> failure x
  | Comprehension (bindings, expr) -> failure x
  | Consolidation (bindings, expr) -> failure x
  | Filtration (bindings, patterns, expr) -> failure x
  | Concentration (bindings, patterns, expr) -> failure x
  | Equation (expr0, expr) -> failure x
  | ComparisonLT (expr0, expr) -> failure x
  | ComparisonGT (expr0, expr) -> failure x
  | ComparisonLTE (expr0, expr) -> failure x
  | ComparisonGTE (expr0, expr) -> failure x
  | Reflection variation -> failure x
  | Acquisition  -> failure x
  | Suspension (expr0, expr) -> failure x
  | Release (expr0, expr) -> failure x
  | InnerSuspension (expr0, expr) -> failure x
  | Calculation arithmeticexpr -> failure x


and transArithmeticExpr (x : arithmeticExpr) : result = match x with
    Division (arithmeticexpr0, arithmeticexpr) -> failure x
  | Addition (arithmeticexpr0, arithmeticexpr) -> failure x
  | Multiplication (arithmeticexpr0, arithmeticexpr) -> failure x
  | Juxtaposition (arithmeticexpr0, arithmeticexpr) -> failure x
  | Negation arithmeticexpr -> failure x
  | Mention variation -> failure x
  | Actualization value -> failure x
  | Aggregation expr -> failure x


and transBinding (x : binding) : result = match x with
    Question (pattern, expr) -> failure x


and transPattern (x : pattern) : result = match x with
    Element (symbol, patterns) -> failure x
  | Variable variation -> failure x
  | Materialization value -> failure x
  | Procession lyst -> failure x
  | PtnSequence variation -> failure x
  | PtnApplication (variation0, variation) -> failure x
  | PtnSupposition (variation0, variation1, variation) -> failure x
  | PtnRecurrence (variation0, variation1, variation) -> failure x
  | PtnAbstraction (variation0, variation) -> failure x
  | PtnCondition (variation0, variation1, variation) -> failure x
  | PtnComprehend (variation0, variation) -> failure x
  | PtnConsolidate (variation0, variation) -> failure x
  | PtnFiltration (variation0, variation1, variation) -> failure x
  | PtnConcentrate (variation0, variation1, variation) -> failure x
  | PtnEquation (variation0, variation) -> failure x
  | PtnCompLT (variation0, variation) -> failure x
  | PtnCompGT (variation0, variation) -> failure x
  | PtnCompLTE (variation0, variation) -> failure x
  | PtnCompGTE (variation0, variation) -> failure x
  | PtnReflection (variation0, variation) -> failure x
  | PtnAcquisition  -> failure x
  | PtnSuspension (variation0, variation) -> failure x
  | PtnRelease (variation0, variation) -> failure x
  | PtnInnerSuspend (variation0, variation) -> failure x
  | PtnDivision (variation0, variation) -> failure x
  | PtnAddition (variation0, variation) -> failure x
  | PtnMultiply (variation0, variation) -> failure x
  | PtnJuxtapose (variation0, variation) -> failure x
  | PtnNegate (variation0, variation) -> failure x


and transVariation (x : variation) : result = match x with
    Atomic uident -> failure x
  | Abandon wild -> failure x
  | Transcription expr -> failure x


and transLyst (x : lyst) : result = match x with
    Empty  -> failure x
  | Enum patterns -> failure x
  | Cons (patterns, lyst) -> failure x
  | ConsV (patterns, variation) -> failure x


and transValue (x : value) : result = match x with
    BooleanLiteral duality -> failure x
  | StringLiteral str -> failure x
  | IntegerLiteral n -> failure x
  | DoubleLiteral d -> failure x
  | Reification expr -> failure x


and transDuality (x : duality) : result = match x with
    Verity  -> failure x
  | Absurdity  -> failure x


and transSymbol (x : symbol) : result = match x with
    Tag lident -> failure x


and transType (x : typeT) : result = match x with
    ProductType (type'0, type') -> failure x
  | AbstractionType typeabstraction -> failure x
  | ApplicationType typeapplication -> failure x
  | FunctionType (type'0, type') -> failure x
  | UserDefinedType lident -> failure x
  | GroundType gtype -> failure x
  | StructuralType structuretype -> failure x


and transTypeAbstraction (x : typeAbstraction) : result = match x with
    TypeListFormals (typevars, type') -> failure x


and transTypeApplication (x : typeApplication) : result = match x with
    TypeListActuals (types, type') -> failure x


and transTypeVar (x : typeVar) : result = match x with
    AtomicTypeVar lident -> failure x
  | TermTypeVar type' -> failure x


and transStructureType (x : structureType) : result = match x with
    ReflectionType type' -> failure x
  | AggregationType type' -> failure x


and transGType (x : gType) : result = match x with
    BooleanType  -> failure x
  | StringType  -> failure x
  | IntegerType  -> failure x
  | FloatType  -> failure x


and transForm (x : form) : result = match x with
    ConjunctiveForm (form0, form) -> failure x
  | DisjunctiveForm (form0, form) -> failure x
  | ImplicativeForm (form0, form) -> failure x
  | ProductiveForm (form0, form) -> failure x
  | AbstractionForm (formformals, form) -> failure x
  | ProbativeForm (form0, form) -> failure x
  | RecursiveForm (uident, form) -> failure x
  | ReflectionForm form -> failure x
  | NegativeForm form -> failure x
  | ReferentialForm uident -> failure x
  | UserDefinedForm lident -> failure x
  | GroundForm gform -> failure x


and transFormFormals (x : formFormals) : result = match x with
    FormOneFormal formvar -> failure x
  | FormListFormals formvars -> failure x


and transFormVar (x : formVar) : result = match x with
    AtomicFormVar lident -> failure x
  | TermFormVar form -> failure x


and transGForm (x : gForm) : result = match x with
    VerityForm  -> failure x
  | AbsurdityForm  -> failure x
  | BooleanForm  -> failure x
  | StringForm  -> failure x
  | IntegerForm  -> failure x
  | FloatForm  -> failure x


and transOuterShellRequest (x : outerShellRequest) : result = match x with
    EscapeRequest str -> failure x
  | PwdRequest  -> failure x
  | CdRequest  -> failure x


and transInnerShellRequest (x : innerShellRequest) : result = match x with
    ExitRequest  -> failure x
  | TypeRequest  -> failure x
  | DesugarRequest  -> failure x
  | ParseRequest  -> failure x



end
