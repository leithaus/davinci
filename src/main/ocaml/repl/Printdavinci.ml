(* pretty-printer generated by the BNF converter *)

open Absdavinci
open Printf

(* We use string buffers for efficient string concatenation.
   A document takes a buffer and an indentation, has side effects on the buffer
   and returns a new indentation. The indentation argument indicates the level
   of indentation to be used if a new line has to be started (because of what is
   already in the buffer) *)
type doc = Buffer.t -> int -> int

let rec printTree (printer : int -> 'a -> doc) (tree : 'a) : string = 
    let buffer_init_size = 16 (* you may want to change this *)
    in let buffer = Buffer.create buffer_init_size
    in 
        let _ = printer 0 tree buffer 0 in (* discard return value *)
        Buffer.contents buffer

let indent_width = 4

let indent (i: int) : string = 
    let s = String.make (i+1) ' ' in
    String.set s 0 '\n';
    s

(* this render function is written for C-style languages, you may want to change it *)
let render (s : string) : doc = fun buf i -> 
    (* invariant: last char of the buffer is never whitespace *)
    let n = Buffer.length buf in
    let last = if n = 0 then None else Some (Buffer.nth buf (n-1)) in
    let whitespace = match last with
        None -> "" 
      | Some '{' -> indent i
      | Some '}' -> (match s with
            ";" -> ""
          | _ -> indent i)
      | Some ';' -> indent i
      | (Some '[') |  (Some '(') -> ""
      | Some _ -> (match s with
            "," | ")" | "]" -> ""
           | _ -> " ") in
    let newindent = match s with
        "{" -> i + indent_width
      | "}" -> i - indent_width
      | _ -> i in
    Buffer.add_string buf whitespace;
    Buffer.add_string buf s;
    newindent

let emptyDoc : doc = fun buf i -> i

let concatD (ds : doc list) : doc = fun buf i -> 
    List.fold_left (fun accIndent elemDoc -> elemDoc buf accIndent) (emptyDoc buf i) ds

let parenth (d:doc) : doc = concatD [render "("; d; render ")"]

let prPrec (i:int) (j:int) (d:doc) : doc = if j<i then parenth d else d


let rec prtChar (_:int) (c:char) : doc = render ("'" ^ Char.escaped c ^ "'")



let rec prtInt (_:int) (i:int) : doc = render (string_of_int i)



let rec prtFloat (_:int) (f:float) : doc = render (sprintf "%f" f)



let rec prtString (_:int) (s:string) : doc = render ("\"" ^ String.escaped s ^ "\"")




let rec prtUIdent _ (UIdent i) : doc = render i


let rec prtLIdent _ (LIdent i) : doc = render i


let rec prtWild _ (Wild i) : doc = render i



let rec prtAgent (i:int) (e:agent) : doc = match e with
       Composition agents -> prPrec i 0 (concatD [render "{" ; prtAgentListBNFC 0 agents ; render "}"])
  |    Superposition guardedagents -> prPrec i 0 (concatD [render "switch" ; render "{" ; prtGuardedAgentListBNFC 0 guardedagents ; render "}"])
  |    Replication channel -> prPrec i 0 (concatD [render "*" ; prtChannel 0 channel])
  |    Reception (bindings, agent) -> prPrec i 0 (concatD [render "for" ; render "(" ; prtBindingListBNFC 0 bindings ; render ")" ; prtAgent 0 agent])
  |    Filtration (bindings, patterns, agent) -> prPrec i 0 (concatD [render "for" ; render "(" ; prtBindingListBNFC 0 bindings ; render "|" ; prtPatternListBNFC 0 patterns ; render ")" ; prtAgent 0 agent])
  |    Intimation (variation, concretion) -> prPrec i 0 (concatD [prtVariation 0 variation ; render "!?" ; render "(" ; prtConcretion 0 concretion ; render ")"])
  |    Transmission (variation, concretion) -> prPrec i 0 (concatD [prtVariation 0 variation ; render "!!" ; render "(" ; prtConcretion 0 concretion ; render ")"])
  |    Actualization value -> prPrec i 0 (concatD [prtValue 0 value])

and prtAgentListBNFC _ es : doc = match es with
    []    -> (concatD [])
  | [x]   -> (concatD [prtAgent 0 x])
  | x::xs -> (concatD [prtAgent 0 x ; render ";" ; prtAgentListBNFC 0 xs])

and prtGuardedAgent (i:int) (e:guardedAgent) : doc = match e with
       Injection (pattern, agent) -> prPrec i 0 (concatD [render "case" ; prtPattern 0 pattern ; render "=>" ; prtAgent 0 agent])

and prtGuardedAgentListBNFC _ es : doc = match es with
    []    -> (concatD [])
  | [x]   -> (concatD [prtGuardedAgent 0 x])
  | x::xs -> (concatD [prtGuardedAgent 0 x ; render ";" ; prtGuardedAgentListBNFC 0 xs])

and prtAbstraction (i:int) (e:abstraction) : doc = match e with
       Applicant (variation, agent) -> prPrec i 0 (concatD [render "(" ; prtVariation 0 variation ; render ")" ; prtAgent 0 agent])


and prtConcretion (i:int) (e:concretion) : doc = match e with
       Applicand information -> prPrec i 0 (concatD [render "(" ; prtInformation 0 information ; render ")"])


and prtBinding (i:int) (e:binding) : doc = match e with
       Question (pattern0, channel, pattern) -> prPrec i 0 (concatD [prtPattern 0 pattern0 ; render "<-" ; prtChannel 0 channel ; render "??" ; render "(" ; prtPattern 0 pattern ; render ")"])
  |    Interrogation (pattern0, channel, pattern) -> prPrec i 0 (concatD [prtPattern 0 pattern0 ; render "<-" ; prtChannel 0 channel ; render "?!" ; render "(" ; prtPattern 0 pattern ; render ")"])

and prtBindingListBNFC _ es : doc = match es with
    []    -> (concatD [])
  | [x]   -> (concatD [prtBinding 0 x])
  | x::xs -> (concatD [prtBinding 0 x ; render ";" ; prtBindingListBNFC 0 xs])

and prtPattern (i:int) (e:pattern) : doc = match e with
       Element (symbol, patterns) -> prPrec i 0 (concatD [prtSymbol 0 symbol ; render "(" ; prtPatternListBNFC 0 patterns ; render ")"])
  |    Variable variation -> prPrec i 0 (concatD [prtVariation 0 variation])
  |    Materialization value -> prPrec i 0 (concatD [prtValue 0 value])
  |    Procession lyst -> prPrec i 0 (concatD [prtLyst 0 lyst])

and prtPatternListBNFC _ es : doc = match es with
  | [x]   -> (concatD [prtPattern 0 x])
  | x::xs -> (concatD [prtPattern 0 x ; render "," ; prtPatternListBNFC 0 xs])

and prtChannel (i:int) (e:channel) : doc = match e with
       Identification lident -> prPrec i 0 (concatD [prtLIdent 0 lident])
  |    Nomination variation -> prPrec i 0 (concatD [prtVariation 0 variation])
  |    Transcription agent -> prPrec i 0 (concatD [render "@" ; render "'" ; prtAgent 0 agent ; render "'"])


and prtSymbol (i:int) (e:symbol) : doc = match e with
       Tag lident -> prPrec i 0 (concatD [prtLIdent 0 lident])


and prtVariation (i:int) (e:variation) : doc = match e with
       Atomic uident -> prPrec i 0 (concatD [prtUIdent 0 uident])


and prtInformation (i:int) (e:information) : doc = match e with
       Indirection variation -> prPrec i 0 (concatD [prtVariation 0 variation])
  |    Reflection agent -> prPrec i 0 (concatD [prtAgent 0 agent])


and prtLyst (i:int) (e:lyst) : doc = match e with
       Empty  -> prPrec i 0 (concatD [render "[" ; render "]"])
  |    Enum patterns -> prPrec i 0 (concatD [render "[" ; prtPatternListBNFC 0 patterns ; render "]"])
  |    Cons (patterns, lyst) -> prPrec i 0 (concatD [render "[" ; prtPatternListBNFC 0 patterns ; render "|" ; prtLyst 0 lyst ; render "]"])
  |    ConsV (patterns, variation) -> prPrec i 0 (concatD [render "[" ; prtPatternListBNFC 0 patterns ; render "|" ; prtVariation 0 variation ; render "]"])


and prtValue (i:int) (e:value) : doc = match e with
       BooleanLiteral duality -> prPrec i 0 (concatD [prtDuality 0 duality])
  |    StringLiteral str -> prPrec i 0 (concatD [prtString 0 str])
  |    IntegerLiteral n -> prPrec i 0 (concatD [prtInt 0 n])
  |    DoubleLiteral d -> prPrec i 0 (concatD [prtFloat 0 d])
  |    Reification agent -> prPrec i 0 (concatD [render "@" ; render "'" ; prtAgent 0 agent ; render "'"])


and prtDuality (i:int) (e:duality) : doc = match e with
       Verity  -> prPrec i 0 (concatD [render "true"])
  |    Absurdity  -> prPrec i 0 (concatD [render "false"])



