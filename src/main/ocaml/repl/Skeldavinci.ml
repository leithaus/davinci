module Skeldavinci = struct

(* OCaml module generated by the BNF converter *)

open Absdavinci

type result = string

let failure x = failwith "Undefined case." (* x discarded *)

let rec transUIdent (x : uIdent) : result = match x with
    UIdent str -> failure x


and transLIdent (x : lIdent) : result = match x with
    LIdent str -> failure x


and transWild (x : wild) : result = match x with
    Wild str -> failure x


and transAgent (x : agent) : result = match x with
    Composition agents -> failure x
  | Superposition guardedagents -> failure x
  | Replication channel -> failure x
  | Reception (bindings, agent) -> failure x
  | Filtration (bindings, patterns, agent) -> failure x
  | Intimation (variation, concretion) -> failure x
  | Transmission (variation, concretion) -> failure x
  | Actualization value -> failure x


and transGuardedAgent (x : guardedAgent) : result = match x with
    Injection (pattern, agent) -> failure x


and transAbstraction (x : abstraction) : result = match x with
    Applicant (variation, agent) -> failure x


and transConcretion (x : concretion) : result = match x with
    Applicand information -> failure x


and transBinding (x : binding) : result = match x with
    Question (pattern0, channel, pattern) -> failure x
  | Interrogation (pattern0, channel, pattern) -> failure x


and transPattern (x : pattern) : result = match x with
    Element (symbol, patterns) -> failure x
  | Variable variation -> failure x
  | Materialization value -> failure x
  | Procession lyst -> failure x


and transChannel (x : channel) : result = match x with
    Identification lident -> failure x
  | Nomination variation -> failure x
  | Transcription agent -> failure x


and transSymbol (x : symbol) : result = match x with
    Tag lident -> failure x


and transVariation (x : variation) : result = match x with
    Atomic uident -> failure x


and transInformation (x : information) : result = match x with
    Indirection variation -> failure x
  | Reflection agent -> failure x


and transLyst (x : lyst) : result = match x with
    Empty  -> failure x
  | Enum patterns -> failure x
  | Cons (patterns, lyst) -> failure x
  | ConsV (patterns, variation) -> failure x


and transValue (x : value) : result = match x with
    BooleanLiteral duality -> failure x
  | StringLiteral str -> failure x
  | IntegerLiteral n -> failure x
  | DoubleLiteral d -> failure x
  | Reification agent -> failure x


and transDuality (x : duality) : result = match x with
    Verity  -> failure x
  | Absurdity  -> failure x



end
