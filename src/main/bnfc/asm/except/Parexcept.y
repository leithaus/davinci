-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module Parexcept where
import Absexcept
import Lexexcept
import ErrM

}

%name pExpr Expr
%name pExpr1 Expr1
%name pExpr2 Expr2
%name pExpr3 Expr3
%name pValue Value
%name pContext Context
%name pPattern Pattern
%name pVariation Variation
%name pGroundValue GroundValue
%name pDuality Duality
%name pLyst Lyst
%name pSymbol Symbol
%name pPrompt Prompt
%name pListExpr1 ListExpr1
%name pListExpr2 ListExpr2
%name pListPattern ListPattern
%name pListVariation ListVariation

-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype { Token }

%token 
 '$' { PT _ (TS _ 1) }
 '%' { PT _ (TS _ 2) }
 '\'' { PT _ (TS _ 3) }
 '(' { PT _ (TS _ 4) }
 ')' { PT _ (TS _ 5) }
 ',' { PT _ (TS _ 6) }
 '->' { PT _ (TS _ 7) }
 ';' { PT _ (TS _ 8) }
 '@' { PT _ (TS _ 9) }
 '[' { PT _ (TS _ 10) }
 '\\' { PT _ (TS _ 11) }
 ']' { PT _ (TS _ 12) }
 '`' { PT _ (TS _ 13) }
 'false' { PT _ (TS _ 14) }
 'raise' { PT _ (TS _ 15) }
 'true' { PT _ (TS _ 16) }
 'try' { PT _ (TS _ 17) }
 '{' { PT _ (TS _ 18) }
 '|' { PT _ (TS _ 19) }
 '}' { PT _ (TS _ 20) }

L_quoted { PT _ (TL $$) }
L_integ  { PT _ (TI $$) }
L_doubl  { PT _ (TD $$) }
L_UIdent { PT _ (T_UIdent $$) }
L_LIdent { PT _ (T_LIdent $$) }
L_Wild { PT _ (T_Wild $$) }
L_err    { _ }


%%

String  :: { String }  : L_quoted {  $1 }
Integer :: { Integer } : L_integ  { (read ( $1)) :: Integer }
Double  :: { Double }  : L_doubl  { (read ( $1)) :: Double }
UIdent    :: { UIdent} : L_UIdent { UIdent ($1)}
LIdent    :: { LIdent} : L_LIdent { LIdent ($1)}
Wild    :: { Wild} : L_Wild { Wild ($1)}

Expr :: { Expr }
Expr : Expr ListExpr1 ';' { EXCApplication $1 $2 } 
  | Expr1 { $1 }


Expr1 :: { Expr }
Expr1 : 'try' Expr1 ListExpr2 ';' { EXCTry $2 $3 } 
  | Expr2 { $1 }


Expr2 :: { Expr }
Expr2 : 'raise' Prompt Expr3 { EXCRaise $2 $3 } 
  | Expr3 { $1 }


Expr3 :: { Expr }
Expr3 : Value { EXCValue $1 } 
  | '(' Expr ')' { $2 }


Value :: { Value }
Value : '\\' ListVariation '->' Expr3 { EXCAbstraction $2 $4 } 
  | '@' Context { EXCSituation $2 }
  | Pattern { EXCMention $1 }
  | Prompt { EXCDelineation $1 }


Context :: { Context }
Context : '{' Context ListExpr2 '}' { EXCLAppCtxt $2 $3 } 
  | '{' Value Context '}' { EXCRAppCtxt $2 $3 }
  | '{' 'try' Prompt Context Expr3 '}' { EXCLTryCtxt $3 $4 $5 }
  | '{' 'try' Prompt Expr3 Context '}' { EXCRTryCtxt $3 $4 $5 }
  | '{' 'raise' Prompt Context '}' { EXCRaiseCtxt $3 $4 }


Pattern :: { Pattern }
Pattern : Symbol '(' ListPattern ')' { EXCElement $1 $3 } 
  | Variation { EXCVariable $1 }
  | GroundValue { EXCMaterialization $1 }
  | Lyst { EXCProcession $1 }


Variation :: { Variation }
Variation : UIdent { EXCAtomic $1 } 
  | Wild { EXCAbandon $1 }
  | '`' Expr3 '\'' { EXCTranscription $2 }


GroundValue :: { GroundValue }
GroundValue : Duality { EXCBooleanLiteral $1 } 
  | String { EXCStringLiteral $1 }
  | Integer { EXCIntegerLiteral $1 }
  | Double { EXCDoubleLiteral $1 }
  | '$' Expr3 '$' { EXCReification $2 }


Duality :: { Duality }
Duality : 'true' { EXCVerity } 
  | 'false' { EXCAbsurdity }


Lyst :: { Lyst }
Lyst : '[' ']' { EXCEmpty } 
  | '[' ListPattern ']' { EXCEnum $2 }
  | '[' ListPattern '|' Lyst ']' { EXCCons $2 $4 }
  | '[' ListPattern '|' Variation ']' { EXCConsV $2 $4 }


Symbol :: { Symbol }
Symbol : LIdent { EXCTag $1 } 


Prompt :: { Prompt }
Prompt : '%' LIdent '%' { EXCPrompt $2 } 


ListExpr1 :: { [Expr] }
ListExpr1 : Expr1 { (:[]) $1 } 
  | Expr1 ListExpr1 { (:) $1 $2 }


ListExpr2 :: { [Expr] }
ListExpr2 : Expr2 { (:[]) $1 } 
  | Expr2 ListExpr2 { (:) $1 $2 }


ListPattern :: { [Pattern] }
ListPattern : Pattern { (:[]) $1 } 
  | Pattern ',' ListPattern { (:) $1 $3 }


ListVariation :: { [Variation] }
ListVariation : Variation { (:[]) $1 } 
  | Variation ',' ListVariation { (:) $1 $3 }



{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

